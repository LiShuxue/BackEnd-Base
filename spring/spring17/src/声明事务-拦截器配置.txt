Spring使用AOP来完成声明事务管理，它是以方法为边界，事务属性就在于描述事务应用至方法上的策略。
事务属性有：
1.传播行为
	定义了应用于方法上的边界，它告诉你的小方法什么时候开始一个新的事务，
	什么时候暂停，方法是否要在事务中进行。

下面有这么几个常量，你得了解了解啊~
PROPAGATION_MANDATORY		方法必须在一个现存的事务中进行，否则抛异常
PROPAGATION_NESTED			在一个嵌入的事务中进行，如果不是，同PROPAGATION_REQUIRED
PROPAGATION_NEVER			不应该在事务中进行，有事务存在，抛异常
PROPAGATION_NOT_SUPPORTED	不应该在事务中进行，有事务存在，就暂停这个事务
PROPAGATION_REQUIRED		代码中自己编程写事务了，就用你写的，否则给它填个新事务（最常用的）
PROPAGATION_REQUIRES_NEW	必须添加使用新给它的事务，以前有也不好使，暂停它
PROPAGATION_SUPPORTS		如果你编程了一个事务，就用它。如果没有的话...那就按没有执行（呵呵）

2.隔离层级
	说，在一个程序里面，可能有多个事务同时在执行，他们相互应该互不干扰，互不察觉（你觉得嘞？）
	如果程序中就一个事务啊，彼此独立，当他们读取同一个数据的话？
	
	1.1 某个事务已经更新一份数据，另一个事务读取了同一份数据，由于种种原因，前一个滚了，
		后一个事务查询的数据就是错误滴。
		
	1.2 在一个事务的两次查询中数据不一样，有可能是因为两次查询过程中，有另一个事务更新了原有数据。
		
	1.3 在一个事务的两次查询中数据量不一样，比如有一个事务查询了几行数据，而另一个事务却在这个时候
		插入了几行新数据，先前的事务在接下来的查询中，就会发现有几行数据是它之前所没有的。
		
	咱们为了避免以上的问题，需要在事务进行过程中“锁定”正在更新或查询的数据，直到目前的事务完成，
	但是完全锁定字段时，另一个事务来查询同一份数据就必须等待，直到前一个事务完成并解锁。
	但是这会带来效率上的问题，根据不同需求使用不同的“隔离层级”
	
ISOLATION_DEFAULT			使用底层数据预设的隔离层级
ISOLATION_READ_COMMITTED	允许事务读取其它并行事务已经提交的数据字段，防止1.1
ISOLATION_READ_UNCOMMITTED	允许事务读取其它并行的事务还没提交的数据，会发生以上3个问题哦~
ISOLATION_REPEATABLE_READ	要求多次读取的数据必须相同，除非事务本身更新数据，防止1.1  1.2
ISOLATION_SERIALIZABLE		完整的隔离层级，三防，锁定对应的数据表，效率会低哦~


3.只读提示
	如果事务进行读取的动作，则可以利用底层数据库在只读操作时发生的一些最佳化动作，由于这个动作利用到
	数据库在只读的事务操作最佳化，因而必须在事务中才有效，也就是说要搭配传播行为PROPAGATION_REQUIRED，
	PROPAGATION_REQUIRED_NEW ， PROPAGATION_NESTED
	
4.事务超时时间
	有的事务可能延续很长一段时间，事务本身可能关联到数据库表的锁定，因而长时间的事务操作会有效率上的问题，
	对于过长的事务操作，我们要将它回滚，然后重新开始，而不是无限期的等待事务完成。
	你可以设置事务的超时时间，计时从事务开始，必须搭配传播行为PROPAGATION_REQUIRED，
	PROPAGATION_REQUIRED_NEW ， PROPAGATION_NESTED 来设置。
	
	
	
	
	
	
	