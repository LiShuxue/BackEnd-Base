注意使用\t\n来调整输出内容

char ch = '';  String str = "";

任意类型与字符串相连接都会转成字符串，这样可以通过连接""空串，来使其变成字符串，然后调用.length()方法求长度
String s = String.valueOf(b); 
b可以为int,long,boolean,char,float,double,object 这样可以把这个类型转换为字符串s

标识符不能用数字开头，符号只能用  _ 或者 $
包名：都小写   xxyy
类名接口名：多单词时，所有单词的首字母大写    XxxYyy
变量名和函数名：多单词时，第一个单词小写，后面的单词首字母都大写    xxxYyy
常量名：所有字母都大写，多个单词之间用下划线隔开       XXX_YYY_ZZZ

String 不是基本数据类型

类型	              所占		 占用存储	
Byte	1字节		8位		
short	2字节		16位		
int	    4字节		32位		
long	8字节		64位		
float	4字节		32位		
double	8字节		64位		
char	2字节		16位		
boolean	     	1位	

常用数据类型的包装类型.MAX_VALUE或.MIN_VALUE可以得到类型的取值范围
如Integer.MIN_VALUE,Integer.MAX_VALUE
存储数据的时候，不能超出范围

//int e = 7;
//e = e + (e++);   //此时e是14   7+7
//e = (e++) + e;   //此时e是15   7+8   相当于 e+= (e++)      没什么太大用

转义符 /   有时候要换行的时候用\n不好用，可以用\r\n

小括号的优先级最高，赋值运算符的优先级最低

判断一串字符是否仅为数字：
public boolean isNum(String str) {
		for (int i = str.length(); --i >= 0;) {
			if (!Character.isDigit(str.charAt(i))) {
				return false;
			}
		}
		return true;
	}
引自http://my.oschina.net/u/1444624/blog/355337;  http://javapub.iteye.com/blog/666544

使用java.lang包中的资源，是不需要导包的

.equals()方法，比较的时候是一个字符一个字符比较，区别于"=="；
==判断是不是同一个对象，字符串的判断不可以用==
.equals()方法，一般将常量放前面，"a".equals(str);
这里主要考虑str变量的情况，当引用一个变量（对象时），可能这个变量指向了一个空指针，就是没有指向具体的对象，
如果这样调用str.equals("a")，当str==null时就会出现空指针异常。

java虚拟机里有一个区域叫方法区，方法区里有一个常量区，如果你是String str = "abc",虚拟机认为“abc”是常量，放在常量区。
下次你再定义String otherStr = “abc", 虚拟机并不新创建任何东西，而是连到刚才常量区里的”abc“，所以不管是equal还是==，都相等，因为值和地址都相等。 
另外还有一个区域叫堆，如果String str = new String("abc"), 虚拟机会创建对象放到堆里，再String otherStr = new String("abc")，会在堆里放两个对象。
所以==就是false，因为两个对象地址不同。

在Java 6及之前，case语句中的常量只能是byte、char、short和int（也可以是对应的封装类型 Byte、Character、Short和Integer）或枚举常量。
Java 7规范中增加了String，毕竟它也是常量类型。 
case后面只能跟常量表达式

无论default在switch语句中的哪个位置，编译器都会先找case,程序从第1个找到的case开始执行，如果所有的case都不满足条件，才会执行default。
因此，default的位置可以随便放。但是出于编码规范考虑，一般写在最后，也可以不写的。

input.hasNextInt(),可以在接收输入之前判断你输入的是否是一个数字，并返回boolean的值,同样也有hasNextDouble(),,,等。

System.exit(n)。终止当前正在运行的 Java 虚拟机。参数用作状态码，根据惯例，非 0 的状态码表示异常终止。 
该方法调用 Runtime 类中的 exit 方法。该方法永远不会正常返回。 
调用 System.exit(n) 实际上等效于调用： Runtime.getRuntime().exit(n)

Thread.sleep(1000),让程序等待一秒

while循环适合用于不知道循环次数的情况，知道的话就可以用for循环，do while循环一般不用

for循环中可以省略某个部分，但" ; "不可以省略。
int i = 0;
for( ; i<5; i++){。。。。}

for(int i=0,j=val; i<=val; i++,j--),for循环也可以这样定义，多个初值，多个循环加减

String.toCharArray 方法 ,作用：将字符串转换为字符数组。
public String toString()返回该对象的字符串表示
toString() 只适用于对象的调用，普通的数据类型不可以调用，这也就是使用包装类的原因。
int a = 123;
Integer aa = new Integer(a);
String s = aa.toString();
System.out.println(s);    这样就可以将数字转换为字符串

在创建对象的时候用接口创建，【接口名】 【对象名】=new 【实现接口的类】，这样你想用哪个类的对象就可以new哪个对象了，不需要改原来的代码
这个就叫统一访问，因为你实现这个接口的类的方法名相同，但是实现内容不同

new一个int数组，默认值全是0，boolean数组默认是false，String数组默认全是null。声明数组时不规定数组长度，分配空间时规定长度

先声明，后赋值：int[] a;   a={1,2,3};  这样的写法是不对的，数组只能通过new来初始化，如a=new int[]{1,2,3} 或者  a = new int[3]
声明并赋值：int[] a = {1,2,3,4};这样赋值只能连着写，不能分开写，分开写的时候要用new  int[] a = new int[]{1,2,3};  int[] a= new int[3];
数组的长度还可以通过一个变量来设置。int len = 20;  int[] array = new int[len];

Arrays.toString(数组a):以字符串的形式显示数组元素。只要是基本数据类型的数组都可以，对象数组也可以
Arrays.sort(数组):对数组进行升序排序，数组类型可以为int，short，byte,char,float,double.

for each循环  : for(int e: 数组a){..} 每次循环会将一个元素取出赋值给e，循环的次数按数组的长度，中途也是可以break 的

一个数组赋值给另一个空的数组的时候，只是将索引赋值给另一个，并不会开辟新空间。因为数组属于引用类型，我们常用的一些，像int这种属于基本数据类型
int[] a ={1,2,3}; 
int[] b=a; 
a[1]=100;   此时b[1]也是100。当有一方修改数组的值的时候，会影响所有的引用者
这也包括对象的赋值。如果一个对象s1赋值给另一个对象s2，然后用第二个对象s2去修改其中的属性s2.xxx,那么s1的这个属性就将是通过s2修改后的值
这种的赋值都是赋值的引用，而不是开辟一个新空间

二维数组可以不规定列数。int[][] a = new int[5][].  a.length 是指行数。  a[0].length是指列数

对象可以调用自己的所有属性（变量）和方法，静态static的属性或方法可以直接通过类名去调用

对象的赋值是引用赋值，一个修改后，其他的跟着变

-----------------------------------------------------------------------------------------------------------------------

属性访问级别：1.什么都不写：包可见       2.private：只能在自己的类中    3.public：任意位置都可以访问    4.protected：子类，同包中
没有包的类可以访问有包的类，反之不可以

如果返回值是void，依然可以用return， return用来终止函数，但是一般是有条件得， 不能随便终止。 不是void也可以被终止

return只能返回一个值，如果需要返回多个值，可以用数组或集合

类的下面不能直接写判断，循环，输出等语句，只能写在方法里面

当方法里定义了局部变量，并且和类的属性同名的时候，方法内默认采用局部变量。 
在属性或变量前加上this.，来表示调用当前类的属性或变量，而不是局部变量

一个类中的方法是可以互相访问的，而不用通过对象来调用，如果非要用对象调用，可以用this.来调用，this表示当前的对象

String s = new String(a),a为字符数组，可以将字符数组转换为字符串
字符串的连接也可以用+，如    s+=s1; 就是将s后面连接上s1，然后在赋值给s

方法里面尽量不要写输出语句

方法的重载，同名不同参。参数必须不同（类型，数量， 顺序），返回值类型可同可不同

实参（简单基本数据类型和String类型）的传递是值传递，传进去的只是一个副本，传进去的参数在方法里面不管怎么改变，都不会影响传参之前的参数值
对象的传参，传进去的是引用，即里面的变了，外面的也跟着变
对于参数传递，如果是简单基本数据类型和String类型，那么它传递的是值拷贝，对于对象，它传递的是对象的引用。需要注意的是，这条规则只适用于参数传递。
String是一个特殊的引用类型

数组也是对象类型，int float char这些基本类型不是对象。
关于如何判断基本类型和对象，参考下面的：
行为：   基本类型只是一个值，没有任何行为                  对象类型有自己的行为
内存分配：  基本类型在栈内分配                                       对象在堆内分配
引用与值：
	基本类型是值类型，仅表示一个值，保存在栈内
	引用类型分两部分，对象引用保存在栈内，对象保存在堆内
访问变量，是使用的引用找对象

构造方法，初始化对象， 与类名相同，无返回值类型的那部分，不能用return， 如 public Student() {},可以有参数，
无参的构造方法会将属性默认赋初始值，数值为0 ，布尔为false， 引用为null
构造方法也是可以重载的，与普通的方法是一样的

匿名对象，就是对象没有名字，一般用在这个new出来的对象只用一次的情况下，所以不把它保存在“变量中”，也就没有名字了

this(); 可以调用构造方法，但必须写在第一行，且必须写在当前类的构造器中

静态static可以用来修饰：属性， 方法，代码块（块主要用来实例化当前对象之前做的初始化工作，不必写在构造方法之前，位置可以随便写，每一次创建对象之前，块都会执行一次）
静态的属性或方法不是对象的，而是对象所共有的资源，属于类资源，程序启动时，所有的静态资源都会被加载到内存，使用的时候内存直接调用，而非静态的资源只有在你调用的时候，才会加载至内存
一般要用类名去访问，不推荐用对象去调用，静态尽量谨慎使用，不要随便乱用
只要程序开着，对静态属性的操作永远都是有效的，除非程序终止
静态块，创建对象之前来做初始化工作，但是只有在第一次实例化对象时， 才会执行，之后就不再执行了，不必写在构造方法前，位置可以随便写。与非静态块作区分
静态方法中只能直接访问静态成员，不能使用非静态成员
静态方法不能使用this，super关键字
静态方法不能被重写，不能修饰构造器

单例模式的三个步骤：        （使用单例模式的类，只有一个对象而且不可以实例化这个类）
1.私有化类的构造
2.定义一个 私有的 静态的 当前类的对象作为属性
3.通过一个 公有的 静态的 方法（一般起名为getInstance()） 来返回该属性

子类继承父类   所有的属性和方法,但不能继承父类的构造方法，同时也可以增加自己的属性和方法。
子类可以继承父类的私有成员，只是子类不能访问那些私有成员而已。

实例化子类时，先实例化父类

super() 调用父类的无参构造或有参构造，且只能写在子类构造的第一行。子类创建对象时，会先调用父类的构造
继承的时候，子类的构造方法中虚拟机会默认在第一行加一个super();也就是默认先调父类的无参构造方法
调了父类的构造以后，父类的一些属性被初始化，然后再继承给子类

子类可以重写父类中的方法，此时就不再继承父类的方法中的内容，而是使用自己写的方法中内容
重写相当于覆盖，必须和父类的方法签名一模一样（访问修饰符可以从protected变为public，也就是可以增大访问权限，但不能降低访问权限。返回值类型和参数都不能改变），但是内容不一样。
注意和重载的区别，重载主要要求不同的参数,返回值类型可同可不同

类中如果写了一个带参数的构造，虚拟机就不会再添加无参构造了，这时，如果一个类继承了这个类，而子类里面又没有写构造方法，会编译失败
这时就不能实例化子类，因为实例化子类时会在子类的默认构造方法中第一行先super（），而父类又没有无参构造

多态：
通过父类型去代表某个子类型     父类Person p = new 子类Student();
参数，返回值的多态：参数是父类型，可以传入任意子类型。   返回值是父类型，可以返回任意子类型

变量之间的赋值是赋引用

instanceof关键字可以判断一个对象是否是某个类（接口）的对象，判断将返回一个boolean值。    对象  instanceof 类           子类的对象 instanceof 父类 （多态形式）
任何类都是Object子类，如果将一个类多态到了object类，那么他自己扩展的属性，方法  将不能调用。   如    Object obj = new Student();
这个obj对象再想转回去的话就得强制转换。  如 Student s = (Student)obj; 
向上会自动转换，叫多态，向下就得强制转换
从父类可以强转为子类，前提是：此父类对象为子类对象强转的结果 例如：
  Father father = (Father)son;
当这种情况时，可以用instanceof判断是否是子类类型（实际） 然后强转回去
  if(father instanceof Son)
     Son son =(Son)father;
除此之外，不行。

输出对象的时候会默认调用toString()方法。 如syso(s) 等于  syso(s.toString())

this.getClass().getName(),获得当前类的对象的包名类名，返回的是一个字符串。 也可以用对象来调这两个方法

抽象类不能被实例化。抽象类包含的抽象方法必须在其子类中实现，否则该子类也是抽象类。抽象方法不能是static
类实现了接口，接口中的抽象方法必须全部实现，不然报错。而如果抽象类实现了这个接口，可以不用全部实现这些方法，这个抽象类的子类如果不实现，那么这个子类也是抽象类

接口中的常量：public static final    接口中方法：public abstract   都会自动补全这些，且必须是这样的

A a = new A();并且类A实现了i1,i2,i3三个接口，
此时若  i1 s = a; 即a这个对象多态到了接口 i1,s就只能调用i1接口中的方法，而不能调用其他的，尽管类A同时实现了其他接口

final修饰常量，常量只能进行一次赋值。把final加在类上，类不能被继承，final加在方法上，方法不能被重写. 参数final，则这个方法里这个参数也不能被赋值

接口中的常量，可以直接用  接口名.常量名 来使用
若一个类实现了该接口，也可以用  类名.常量名 来使用。      因为接口中的常量是static的

静态方法不能调用非静态属性，非静态方法可以调用静态属性

接口是可以继承的，且可以多继承。   类可以单继承，多实现

类中可以定义接口或类（内部类），而接口中也可以定义类
内部类可以直接访问其外部类的属性和方法， 而外部类想访问其内部类，需要通过内部类的对象，同名情况下，内部类优先级更高
在外部类内访问内部类，直接创建内部类的对象，而在外部类外访问内部类，需要通过   外部类的对象.new内部类，这跟在外部类中的main方法中是一样的，而其他方法中可以直接创建内部类对象就行
内部类的作用一般就是为了隐藏。一般不用内部类。

局部内部类:在一个类的方法体中或程序块中定义的内部类。只能访问方法中的final类型的局部变量

想使用抽象类中的方法时，1.通过子类继承抽象类并实现所有的方法，再实例化子类的对象，用这个对象调方法。
2.通过匿名内部类，就是直接new这个抽象类，然后在后面实现其中的方法。 抽象类或接口   对象  = new 抽象类或接口(){ 实现的方法()}; 
然后在通过对象调匿名内部类中实现的方法 ，对象.实现的方法()。     在接口中，也可以这样使用。     花括号的里面就是匿名内部类
如果直接 new 抽象类或接口(){ 实现的方法()}.实现的方法()。 就叫做匿名内部类的匿名对象 调方法

s.trim()去掉字符串两端的空格,而不能去掉中间的空格
equalsIgnoreCase(),忽略字符串的大小写来比较两个字符串   返回boolean
toLowerCase()转换为小写
toUpperCase()转换为大写
concat(String str)将两个字符串连接，返回连接后的字符串
indexOf(char 或  String)查找一个字符串中是否包含某个字符或字符串，返回值int, 第一个位置为0， 没找到返回-1
lastIndexOf(char 或  String)，从后面查找，返回结果同上
substring(int  或    int，int)从指定位置开始截取字符串，开始位置是0.或者截取两个位置之间的串，从第一个位置开始，到第二个位置，但不包括第二位置的个字符
spilt()方法，将一个字符串分割为子串，并返回一个字符串数组

StringBuffer,一个类似于 String 的字符串缓冲区.用于频繁操作字符串时候使用，提高效率.
拿字符串或空串创建StringBuffer。 StringBuffer sb = new StringBuffer("xx");
sb.append("xx"),可以在sb后面加上一个串，而且时间很短
sb.insert()将某个类型的字符串插入到sb字符串中

s.next()方法不能接收空格，空格以后的全部不接受

可以写多个catch，以捕获不同类型的异常，catch的子类不能写在父类之后，不然子类的异常永远不能执行，且报错，子类在父类前的话，就不执行父类的

catch后面的代码依然可以执行，因为已经捕获处理了，处理的时候再抛出异常的话，后面的代码就不执行了

throw：手动抛出异常 ，用来终止方法的执行
throws后面可以有多个异常，中间用逗号隔开

finally语句放在try catch 语句后，不管异常是否被处理，finally语句总是执行，不管是return还是break都执行，除了System.exit（0）。前提是这些中断的都是在try catch中。
有finally时catch可以不写
try中异常之后的代码不执行，但是catch中的代码可以执行

e.getMessage()可以得到异常信息

自定义异常类就是用来抛的

SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。
SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");
sf.format(Date date);将一个 Date 格式化为日期/时间字符串。
sf.parse(String source);从给定字符串的开始解析文本，以生成一个日期。该方法不使用给定字符串的整个文本。

date.getTime();返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。返回值是一个long型
两个日期之间的天数：date1,date2，两个Date类型
int day = (int)((date2.getTime()-date1.getTime())/(1000*60*60*24))

clone()创建并返回此对象的一个副本，这是Object类的方法,调用的时候一般要重写这个方法，方法里面去实现克隆，通过新建一个此类的对象，调用有参构造，实现克隆，
并返回此新的对象，并且将返回类型声明为你的所要返回的对象的类型（原来返回类型是Object类型），该方法会抛出一个异常
一般第一行是super.clone();

DAO层是用来专门操作数据的，对数据进行增删改查的
Service业务层通过DAO的对象去调用DAO层，而业务层并不知道数据库的存在
UI层通过Service的对象去调用Service层，而不用关心具体的逻辑操作，只用其功能
所有输出的内容全在UI里面实现，而不要在其他地方实现

------------------------------------------------------------------------------------------------------------------------

